analyticGMV = function(returns)
{
S = cov(returns)
Sinv = solve(S)
one = rep(1, ncol(S))
denom = as.numeric(t(one) %*% Sinv %*% one)
w = (Sinv %*% one) / denom
sd = 1 / sqrt(denom)
rslt = list(w = round(t(w), 8), mu = mean(returns %*% w), sd = sd)
return(rslt)
}
#
# Calculate the weights, mean return and standard deviation of the
# tangency portfolio.
#
analyticTangency = function(returns, rf)
{
mu = apply(returns, 2, mean)
S = cov(returns)
Sinv = solve(S)
one = rep(1, ncol(S))
mu_e = mu - rf
w = (Sinv %*% mu_e) / as.numeric((t(one) %*% Sinv %*% mu_e))
sd = sqrt(t(w) %*% S %*% w)
rslt = list(w = round(t(w), 6), mu = sum(w * mu), sd = sd)
return(rslt)
}
#
# Given two Markowitz mean/variance optimized portfolio weights, calculate a set of
# means and 5% CVaR values for the efficient frontier using the "two fund theorm".
# Note that these are not CVaR optimized portfolio.  The CVaR value is calculated
# from the weighted return distribution.
#
meanETLPoints = function(returns, gmv_wts, tan_wts, alpha = seq(from=-0.1, to=1.1, by=0.05))
{
y_mu = list()
x_etl = list()
gmv_wts_t = as.vector(gmv_wts)
tan_wts_t = as.vector(tan_wts)
C = cov(returns)
ix = 1
mu = apply(returns, 2, mean)
for (i in alpha) {
w = i * gmv_wts_t + ((1-i) * tan_wts_t)
y_mu[ix] = mu %*% w
x_etl[ix] = cvarRisk(returns, w)
ix = ix + 1
}
rslt = list(mu=y_mu, etl=x_etl)
return(rslt)
}
#
# Calculate the efficient frontier for CVaR (ETL) optimized portfolios between a mininum mean
# and a maximum mean. This is done by calculating portfolios for a given target return.
#
etlPoints = function(returns.ts, minMu, maxMu )
{
spec = portfolioSpec()
setType(spec) = "CVaR"
constraints = "Short"
setSolver(spec)  = "solveRglpk.CVAR"
nPts = 40
muRange = seq(from=minMu, to=maxMu, by=((maxMu - minMu)/nPts))
mu = list()
etl = list()
for (i in 1:length(muRange)) {
targetMu = muRange[i]
setTargetReturn( spec ) = targetMu
port = efficientPortfolio(data=returns.ts, spec=spec, constraints=constraints)
mu[i] = targetMu
etl[i] = cvarRisk(returns.ts, getWeights(port))
}
rslt = list(mu = mu, etl = etl)
}
readhorizon <- function()
{
rl <- readline(prompt="Enter the required Horizon (S for Short, M for Medium, L for Long): ")
if(!grepl("[S,M,L]",rl))
{
return(readhorizon())
}
return(as.character(rl))
}
etf_return = "http://news.morningstar.com/etf/lists/ETFReturns.html?topNum=All&lastRecNum=100000&curField=8&category=0"
etf_return_raw.table = readHTMLTable(etf_return,which=3,stringsAsFactors=F)
funds_return ="http://news.morningstar.com/fund-category-returns"
funds_return_raw.table = readHTMLTable(funds_return,which=1,stringsAsFactors=F)
colnames(funds_return_raw.table)[1] = "Name" ## remove space from the colname
nr_etf=nrow(etf_return_raw.table) -1
nc_etf=ncol(etf_return_raw.table) -1
## Data cleansing
##etf_return.table= etf_return_raw.table[50:70,]
##etf_return.table=unique(etf_return.table)
etf_return.table= unique(etf_return_raw.table)
etf_return.table=etf_return.table[,2:nc_etf] ## remove blank columns
##etf_return.table=etf_return.table[-(which(is.na(etf_return.table[,1]))),] ## remove rows with NA value
colnames(etf_return.table)=etf_return.table[1,] ## set column names
etf_return.table=na.omit(etf_return.table) ## removing na values from the data frame
colnames(etf_return.table)[2] = "SubCategory" ## renaming the column to sub-category
etf_return.table <- etf_return.table[order(etf_return.table$SubCategory), ] ## sorting by sub category
funds_return.table=unique(funds_return_raw.table[,1:2])
##colnames(funds_return.table) <- sub(" ", "", colnames(funds_return.table)) ## remove spaces from colnames
colnames(funds_return.table)[2] = "onemonth_perc"
## creating a dataframe for category and sub-category
category=data.frame(matrix(NA, nrow = nrow(funds_return.table), ncol = ncol(funds_return.table))) ## creating a dataframe
colnames(category)=c("cat","subcat") ## giving column names
for (i in 1:nrow(funds_return.table))
{
if ( is.na(funds_return.table$onemonth_perc[i]) )
{
categ=funds_return.table$Name[i]
subcateg = ""
}
else
{
subcateg=funds_return.table$Name[i]
}
if (length(subcateg) > 0)
{
category$cat[i]=categ
category$subcat[i]=subcateg
}
}
## Merging to get category column in the dataframe
etf_return.table=merge(etf_return.table,category,by.x="SubCategory", by.y="subcat", all.x=T)
## processing the dataframe to get the symbols
## use str_sub to cut the string from back
## use sub to replace spaces and gsub to replace brackets
##etf_return.table$Symbol=gsub("\\(|\\)", "",sub(" ", "", str_sub(etf_return.table$Name,-6,-1)))
etf_return.table$Symbol=sapply(str_sub(etf_return.table$Name,-6,-1),function(x) str_sub(x,str_locate(x,"\\(")[1] +1,str_length(x)-1) )
## remove rows having category as NA
etf_return.table = na.omit(etf_return.table)
## sorting by category
etf_return.table <- etf_return.table[order(etf_return.table$cat), ] ## sorting by sub category
## correcting symbol for qCN
##etf_return.table$Symbol[11]="CN"
## removing rows for symbol IBDN,IBDM
##etf_return.table=etf_return.table[-152,] ## IBDN
##etf_return.table=etf_return.table[-152,] ## IBDM
##etf_return.table=etf_return.table[-152,] ## IBDK
etf_return.table=etf_return.table[-(which(etf_return.table$TradingVolume==0)),] ## remove all rows having tradingvolume=0
etf_return.table=etf_return.table[-(which(etf_return.table$Symbol=="VLSM")),] ## remove VLSM
etf_return.table=etf_return.table[-(which(etf_return.table$Symbol=="EMSA")),] ## remove EMSA
etf_return.table=etf_return.table[-(which(etf_return.table$Symbol=="MFLA")),] ## remove MFLA
etf_return.table=etf_return.table[-(which(etf_return.table$Symbol=="EFNL")),] ## remove EFNL
etf_return.table=etf_return.table[-which(etf_return.table$Symbol==""),] ## remove blank symbol
colnames(etf_return.table) = gsub("%", "perc",sub(" ", "", colnames(etf_return.table)) )
etf_return.table = etf_return.table[-which(etf_return.table$YTDReturnperc == "---"),]
##-------------------cleansing and formatting over--------------------------------------------##
##-------------------Pull quotes from yahoo--------------------------------------------##
etf_return = "http://news.morningstar.com/etf/lists/ETFReturns.html?topNum=All&lastRecNum=100000&curField=8&category=0"
etf_return_raw.table = readHTMLTable(etf_return,which=3,stringsAsFactors=F)
etf_return_raw.table = readHTMLTable(etf_return,which=3,stringsAsFactors=F)
etf_return_raw.table = readHTMLTable(etf_return,which=3,stringsAsFactors=F)
etf_return_raw.table = readHTMLTable(etf_return,which=3,stringsAsFactors=F)
etf_return = "http://news.morningstar.com/etf/lists/ETFReturns.html?topNum=All&lastRecNum=100000&curField=8&category=0"
etf_return_raw.table = readHTMLTable(etf_return,which=3,stringsAsFactors=F)
funds_return ="http://news.morningstar.com/fund-category-returns"
funds_return_raw.table = readHTMLTable(funds_return,which=1,stringsAsFactors=F)
colnames(funds_return_raw.table)[1] = "Name" ## remove space from the colname
nr_etf=nrow(etf_return_raw.table) -1
nc_etf=ncol(etf_return_raw.table) -1
## Data cleansing
##etf_return.table= etf_return_raw.table[50:70,]
##etf_return.table=unique(etf_return.table)
etf_return.table= unique(etf_return_raw.table)
etf_return.table=etf_return.table[,2:nc_etf] ## remove blank columns
##etf_return.table=etf_return.table[-(which(is.na(etf_return.table[,1]))),] ## remove rows with NA value
colnames(etf_return.table)=etf_return.table[1,] ## set column names
etf_return.table=na.omit(etf_return.table) ## removing na values from the data frame
colnames(etf_return.table)[2] = "SubCategory" ## renaming the column to sub-category
etf_return.table <- etf_return.table[order(etf_return.table$SubCategory), ] ## sorting by sub category
funds_return.table=unique(funds_return_raw.table[,1:2])
##colnames(funds_return.table) <- sub(" ", "", colnames(funds_return.table)) ## remove spaces from colnames
colnames(funds_return.table)[2] = "onemonth_perc"
## creating a dataframe for category and sub-category
category=data.frame(matrix(NA, nrow = nrow(funds_return.table), ncol = ncol(funds_return.table))) ## creating a dataframe
colnames(category)=c("cat","subcat") ## giving column names
for (i in 1:nrow(funds_return.table))
{
if ( is.na(funds_return.table$onemonth_perc[i]) )
{
categ=funds_return.table$Name[i]
subcateg = ""
}
else
{
subcateg=funds_return.table$Name[i]
}
if (length(subcateg) > 0)
{
category$cat[i]=categ
category$subcat[i]=subcateg
}
}
## Merging to get category column in the dataframe
etf_return.table=merge(etf_return.table,category,by.x="SubCategory", by.y="subcat", all.x=T)
## processing the dataframe to get the symbols
## use str_sub to cut the string from back
## use sub to replace spaces and gsub to replace brackets
##etf_return.table$Symbol=gsub("\\(|\\)", "",sub(" ", "", str_sub(etf_return.table$Name,-6,-1)))
etf_return.table$Symbol=sapply(str_sub(etf_return.table$Name,-6,-1),function(x) str_sub(x,str_locate(x,"\\(")[1] +1,str_length(x)-1) )
## remove rows having category as NA
etf_return.table = na.omit(etf_return.table)
## sorting by category
etf_return.table <- etf_return.table[order(etf_return.table$cat), ] ## sorting by sub category
## correcting symbol for qCN
##etf_return.table$Symbol[11]="CN"
## removing rows for symbol IBDN,IBDM
##etf_return.table=etf_return.table[-152,] ## IBDN
##etf_return.table=etf_return.table[-152,] ## IBDM
##etf_return.table=etf_return.table[-152,] ## IBDK
etf_return.table=etf_return.table[-(which(etf_return.table$TradingVolume==0)),] ## remove all rows having tradingvolume=0
etf_return.table=etf_return.table[-(which(etf_return.table$Symbol=="VLSM")),] ## remove VLSM
etf_return.table=etf_return.table[-(which(etf_return.table$Symbol=="EMSA")),] ## remove EMSA
etf_return.table=etf_return.table[-(which(etf_return.table$Symbol=="MFLA")),] ## remove MFLA
etf_return.table=etf_return.table[-(which(etf_return.table$Symbol=="EFNL")),] ## remove EFNL
etf_return.table=etf_return.table[-which(etf_return.table$Symbol==""),] ## remove blank symbol
colnames(etf_return.table) = gsub("%", "perc",sub(" ", "", colnames(etf_return.table)) )
etf_return.table = etf_return.table[-which(etf_return.table$YTDReturnperc == "---"),]
horizon = readhorizon()
S={
startDate = (Sys.Date() - 3)
endDate  = (Sys.Date() - 123)
period = "d"
},
M={
startDate = (Sys.Date() - 3)
endDate  = (Sys.Date() - 733)
period = "w"
},
L={
startDate = (Sys.Date() - 3)
endDate  = (Sys.Date() - 3650)
period = "m"},
{
print('default')
}
)
horizon = readhorizon()
S={
startDate = (Sys.Date() - 3)
endDate  = (Sys.Date() - 123)
period = "d"
},
M={
startDate = (Sys.Date() - 3)
endDate  = (Sys.Date() - 733)
period = "w"
},
L={
startDate = (Sys.Date() - 3)
endDate  = (Sys.Date() - 3650)
period = "m"},
{
print('default')
}
)
horizon = readhorizon()
switch(horizon,
S={
startDate = (Sys.Date() - 3)
endDate  = (Sys.Date() - 123)
period = "d"
},
M={
startDate = (Sys.Date() - 3)
endDate  = (Sys.Date() - 733)
period = "w"
},
L={
startDate = (Sys.Date() - 3)
endDate  = (Sys.Date() - 3650)
period = "m"},
{
print('default')
}
)
returnFile="quotes.dat"
rfSym = "^TNX"
rf.mat = buildQuoteMatrix(rfSym, period, startDate, endDate)
buildQuoteMatrix = function( symbols, period, startDate, endDate)
{
for (i in 1:length(symbols))
{
sym = symbols[i]
print(sprintf("Reading symbol %s from yahoo", sym , i))
ts = get.hist.quote( sym, startDate, endDate, provider="yahoo", compression=period, quote="AdjClose", quiet=T)
if (i == 1) {
quote.mat = ts ## timeseries
} else {
quote.mat = cbind(quote.mat, ts)
}
}
colnames(quote.mat) = symbols
return( quote.mat)
} # buildQuoteMatrix
rf.mat = buildQuoteMatrix(rfSym, period, startDate, endDate)
rf.mat = buildQuoteMatrix(rfSym, period="d", startDate, endDate)
rf.mat = buildQuoteMatrix(rfSym, period='d', startDate, endDate)
myghq <- tseries::get.hist.quote
fix(myghq)
rf.mat = buildQuoteMatrix(rfSym, period='d', startDate, endDate)
rf.mat = myghq(rfSym, period='d', startDate, endDate)
library("tseries")
rf.mat = buildQuoteMatrix(rfSym, period='d', startDate, endDate)
??getsymbol
??quantmod
install.packages("tseries")
install.packages("tseries")
install.packages("tseries")
install.packages("tseries")
install.packages("tseries")
install.packages("tseries")
rm(list=ls())
library("tseries")
install.packages("tseries")
install.packages("tseries")
library("tseries")
horizon = readhorizon()
readhorizon <- function()
{
rl <- readline(prompt="Enter the required Horizon (S for Short, M for Medium, L for Long): ")
if(!grepl("[S,M,L]",rl))
{
return(readhorizon())
}
return(as.character(rl))
}
horizon = readhorizon()
switch(horizon,
S={
startDate = (Sys.Date() - 3)
endDate  = (Sys.Date() - 123)
period = "d"
},
M={
startDate = (Sys.Date() - 3)
endDate  = (Sys.Date() - 733)
period = "w"
},
L={
startDate = (Sys.Date() - 3)
endDate  = (Sys.Date() - 3650)
period = "m"},
{
print('default')
}
)
rfSym = "^TNX"
returnFile="quotes.dat"
rf.mat = buildQuoteMatrix(rfSym, period='d', startDate, endDate)
buildQuoteMatrix = function( symbols, period, startDate, endDate)
{
for (i in 1:length(symbols))
{
sym = symbols[i]
print(sprintf("Reading symbol %s from yahoo", sym , i))
ts = get.hist.quote( sym, startDate, endDate, provider="yahoo", compression=period, quote="AdjClose", quiet=T)
if (i == 1) {
quote.mat = ts ## timeseries
} else {
quote.mat = cbind(quote.mat, ts)
}
}
colnames(quote.mat) = symbols
return( quote.mat)
} # buildQuoteMatrix
rf.mat = buildQuoteMatrix(rfSym, period='d', startDate, endDate)
buildQuoteMatrix("YYY", period="d", startDate, endDate)
setwd("D:/Analytics/Analytics_edge/Logistic_Regression/loans")
loans = read.csv("loans.csv")
str(loans)
summary(loans)
table(loans$not.fully.paid)
1533/(1533 + 8045)
library("mice")
missing = subset(loans, is.na(log.annual.inc) | is.na(days.with.cr.line) |
is.na(revol.util) | is.na(inq.last.6mths) | is.na(delinq.2yrs) | is.na(pub.rec))
set.see(144)
set.seed(144)
vars.for.imputation = setdiff(names(loans), "not.fully.paid")
vars.for.imputation
?setdiff
a=c(1,2,3)
b=c(3,4,5)
setdiff(a,b)
imputed = complete(mice(loans[vars.for.imputation]))
str(imputed)
loans[vars.for.imputation] = imputed
summary(loans)
library("caTools")
rf.mat = buildQuoteMatrix(rfSym, period="d", startDate, endDate)
buildQuoteMatrix = function( symbols, period, startDate, endDate)
{ print ("values are " , symbols , period , startDate , endDate)
for (i in 1:length(symbols))
{
sym = symbols[i]
print(sprintf("Reading symbol %s from yahoo", sym , i))
ts = get.hist.quote( sym, startDate, endDate, provider="yahoo", compression=period, quote="AdjClose", quiet=T)
if (i == 1) {
quote.mat = ts ## timeseries
} else {
quote.mat = cbind(quote.mat, ts)
}
}
colnames(quote.mat) = symbols
return( quote.mat)
} # buildQuoteMatrix
rf.mat = buildQuoteMatrix(rfSym, period="d", startDate, endDate)
buildQuoteMatrix = function( symbols, period, startDate, endDate)
{ print ("values are " , symbols)
for (i in 1:length(symbols))
{
sym = symbols[i]
print(sprintf("Reading symbol %s from yahoo", sym , i))
ts = get.hist.quote( sym, startDate, endDate, provider="yahoo", compression=period, quote="AdjClose", quiet=T)
if (i == 1) {
quote.mat = ts ## timeseries
} else {
quote.mat = cbind(quote.mat, ts)
}
}
colnames(quote.mat) = symbols
return( quote.mat)
} # buildQuoteMatrix
rf.mat = buildQuoteMatrix(rfSym, period="d", startDate, endDate)
buildQuoteMatrix = function( symbols, period, startDate, endDate)
{ print ("values are " , symbols[1] , period , startDate , endDate)
for (i in 1:length(symbols))
{
sym = symbols[i]
print(sprintf("Reading symbol %s from yahoo", sym , i))
ts = get.hist.quote( sym, startDate, endDate, provider="yahoo", compression=period, quote="AdjClose", quiet=T)
if (i == 1) {
quote.mat = ts ## timeseries
} else {
quote.mat = cbind(quote.mat, ts)
}
}
colnames(quote.mat) = symbols
return( quote.mat)
} # buildQuoteMatrix
rf.mat = buildQuoteMatrix(rfSym, period="d", startDate, endDate)
a=c(1,2,3)
print a
print (a)
b=c(1,2,3)
print (a)
print (a,b)
print (a)
b=c(8,7,6)
print (a,b)
buildQuoteMatrix = function( symbols, period, startDate, endDate)
{ print (symbols[1])
print (period)
print (startDate)
print (endDate)
for (i in 1:length(symbols))
{
sym = symbols[i]
print(sprintf("Reading symbol %s from yahoo", sym , i))
ts = get.hist.quote( sym, startDate, endDate, provider="yahoo", compression=period, quote="AdjClose", quiet=T)
if (i == 1) {
quote.mat = ts ## timeseries
} else {
quote.mat = cbind(quote.mat, ts)
}
}
colnames(quote.mat) = symbols
return( quote.mat)
} # buildQuoteMatrix
rf.mat = buildQuoteMatrix(rfSym, period="d", startDate, endDate)
horizon = readhorizon()
switch(horizon,
S={
endDate = (Sys.Date() - 3)
startDate  = (Sys.Date() - 123)
period = "d"
},
M={
endDate = (Sys.Date() - 3)
startDate  = (Sys.Date() - 733)
period = "w"
},
L={
endDate = (Sys.Date() - 3)
startDate  = (Sys.Date() - 3650)
period = "m"},
{
print('default')
}
)
rf.mat = buildQuoteMatrix(rfSym, period="d", startDate, endDate)
rf.mat = buildQuoteMatrix(rfSym, period, startDate, endDate)
split = sample.split(loans$not.fully.paid,SplitRatio=0.7)
train = subset(loans,split=T)
test = subset(loans,split=F)
str(train)
str(test)
train = subset(loans,split==T)
test = subset(loans,split==F)
str(train)
str(test)
logm = glm(not.fully.paid ~ .,data=train,family=binomial)
summary(logm)
700*(-7.983e-03) - 710(-7.983e-03)
700*(-7.983e-03) - 710*(-7.983e-03)
exp( 7.486e+00 + 700*(-7.983e-03))
exp( 7.486e+00 + 710*(-7.983e-03))
6.671869/6.159958
quit()
